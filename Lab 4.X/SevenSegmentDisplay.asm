; DIGIT DEFS
#DEFINE VAL_DIGIT_ZERO 0xC0
#DEFINE VAL_DIGIT_ONE 0xF9
#DEFINE VAL_DIGIT_TWO 0xA4
#DEFINE VAL_DIGIT_THREE 0xB0
#DEFINE VAL_DIGIT_FOUR 0x99
#DEFINE VAL_DIGIT_FIVE 0x92
#DEFINE VAL_DIGIT_SIX 0x82
#DEFINE VAL_DIGIT_SEVEN 0xF8
#DEFINE VAL_DIGIT_EIGHT 0x80
#DEFINE VAL_DIGIT_NINE 0x98
    
#DEFINE VAL_FIRST_DIGIT_POS 0x3E
#DEFINE VAL_SECOND_DIGIT_POS 0x3D
#DEFINE VAL_THIRD_DIGIT_POS 0x3B
#DEFINE VAL_FOURTH_DIGIT_POS 0x37
#DEFINE VAL_FIFTH_DIGIT_POS 0x2F
#DEFINE VAL_SIXTH_DIGIT_POS 0x1F

#DEFINE MEM_DIGIT_START 0x20
#DEFINE MEM_DIGIT MEM_DIGIT_START + 10
#DEFINE MEM_INNER_DELAY MEM_DIGIT_START + 11
#DEFINE VAL_INNER_DELAY 0xFF
#DEFINE MEM_OUTER_DELAY MEM_DIGIT_START + 12
#DEFINE VAL_OUTER_DELAY 0x04

#DEFINE MEM_DIGIT_POS_START MEM_DIGIT_START + 13
#DEFINE MEM_DIGIT_POS MEM_DIGIT_POS_START + 6
    
#DEFINE MEM_SEG_VALUE_START MEM_DIGIT_POS + 1
    
#DEFINE MEM_SEG_VALUE_OFFSET MEM_SEG_VALUE_START + 6

    
#INCLUDE<P16F877A.INC>
    __CONFIG _DEBUG_OFF&_CP_ALL&_WRT_HALF&_CPD_ON&_LVP_OFF&_BODEN_OFF&_PWRTE_ON&_WDT_OFF&_HS_OSC
    ORG 00H    
MAIN: 
    CALL CONFIGURE_MEMORY
    
    BSF STATUS, RP0 ; SELECT BANK 1
    BCF STATUS, RP1

    MOVLW 06H ; SET OUTS TO DIGITAL
    MOVWF ADCON1

    MOVLW B'11000000' ; SET FIRST SIX PORTS TO OUTPUT
    MOVWF TRISA 

    ; SEGMENTS
    MOVLW 00H ; SET ALL PINS TO OUTPUT
    MOVWF TRISD

    BCF STATUS, RP0 ; SELECT BANK
    BCF STATUS, RP1
    
    GOTO LOOP
    
SET_POS:
    MOVLW MEM_DIGIT_POS_START
    ADDWF MEM_DIGIT_POS, W
    MOVWF FSR
    MOVF INDF, W
    MOVWF PORTA
    RETURN
    
SET_DIGIT:
    MOVLW MEM_DIGIT_START
    ADDWF MEM_DIGIT, W
    MOVWF FSR
    MOVF INDF, W
    MOVWF PORTD
    RETURN
    
DRAW:
    MOVLW 0x00
    MOVWF MEM_DIGIT_POS
    CALL SET_POS
    MOVF MEM_SEG_VALUE_START, W
    MOVWF MEM_DIGIT
    CALL SET_DIGIT
    CALL DELAY
    
    MOVLW 0x01
    MOVWF MEM_DIGIT_POS
    CALL SET_POS
    MOVF MEM_SEG_VALUE_START + 1, W
    MOVWF MEM_DIGIT
    CALL SET_DIGIT
    CALL DELAY
    
    MOVLW 0x02
    MOVWF MEM_DIGIT_POS
    CALL SET_POS
    MOVF MEM_SEG_VALUE_START + 2, W
    MOVWF MEM_DIGIT
    CALL SET_DIGIT
    CALL DELAY
    
    MOVLW 0x03
    MOVWF MEM_DIGIT_POS
    CALL SET_POS
    MOVF MEM_SEG_VALUE_START + 3, W
    MOVWF MEM_DIGIT
    CALL SET_DIGIT
    CALL DELAY
    
    MOVLW 0x04
    MOVWF MEM_DIGIT_POS
    CALL SET_POS
    MOVF MEM_SEG_VALUE_START + 4, W
    MOVWF MEM_DIGIT
    CALL SET_DIGIT
    CALL DELAY
    
    MOVLW 0x05
    MOVWF MEM_DIGIT_POS
    CALL SET_POS
    MOVF MEM_SEG_VALUE_START + 5, W
    MOVWF MEM_DIGIT
    CALL SET_DIGIT
    CALL DELAY
    RETURN
    
DELAY:
    MOVLW VAL_OUTER_DELAY
    MOVWF MEM_OUTER_DELAY
    
OUTER_DELAY_LOOP:
    MOVLW VAL_INNER_DELAY
    MOVWF MEM_INNER_DELAY

INNER_DELAY_LOOP:
    DECFSZ MEM_INNER_DELAY, F
    GOTO INNER_DELAY_LOOP
    
    DECFSZ MEM_OUTER_DELAY, F
    GOTO OUTER_DELAY_LOOP
    RETURN
    
CONFIGURE_MEMORY:
    BCF STATUS, RP0 ; SELECT BANK 0
    BCF STATUS, RP1
       
    ; MOVE ALL DIGITS INTO MEMORY
    MOVLW 0x00
    MOVWF MEM_DIGIT
    
    MOVLW VAL_DIGIT_ZERO
    MOVWF MEM_DIGIT_START
    
    MOVLW VAL_DIGIT_ONE
    MOVWF MEM_DIGIT_START + 1
    
    MOVLW VAL_DIGIT_TWO
    MOVWF MEM_DIGIT_START + 2
    
    MOVLW VAL_DIGIT_THREE
    MOVWF MEM_DIGIT_START + 3
    
    MOVLW VAL_DIGIT_FOUR
    MOVWF MEM_DIGIT_START + 4
    
    MOVLW VAL_DIGIT_FIVE
    MOVWF MEM_DIGIT_START + 5
    
    MOVLW VAL_DIGIT_SIX
    MOVWF MEM_DIGIT_START + 6
    
    MOVLW VAL_DIGIT_SEVEN
    MOVWF MEM_DIGIT_START + 7
    
    MOVLW VAL_DIGIT_EIGHT
    MOVWF MEM_DIGIT_START + 8
    
    MOVLW VAL_DIGIT_NINE
    MOVWF MEM_DIGIT_START + 9
    
    MOVLW 0x00
    MOVWF MEM_DIGIT_POS
    
    MOVLW VAL_FIRST_DIGIT_POS
    MOVWF MEM_DIGIT_POS_START
    
    MOVLW VAL_SECOND_DIGIT_POS
    MOVWF MEM_DIGIT_POS_START + 1
    
    MOVLW VAL_THIRD_DIGIT_POS
    MOVWF MEM_DIGIT_POS_START + 2
    
    MOVLW VAL_FOURTH_DIGIT_POS
    MOVWF MEM_DIGIT_POS_START + 3
    
    MOVLW VAL_FIFTH_DIGIT_POS
    MOVWF MEM_DIGIT_POS_START + 4
    
    MOVLW VAL_SIXTH_DIGIT_POS
    MOVWF MEM_DIGIT_POS_START + 5
    
    MOVLW 0x00
    MOVWF MEM_SEG_VALUE_START
    
    MOVLW 0x00
    MOVWF MEM_SEG_VALUE_START + 1
    
    MOVLW 0x00
    MOVWF MEM_SEG_VALUE_START + 2
    
    MOVLW 0x00
    MOVWF MEM_SEG_VALUE_START + 3
    
    MOVLW 0x00
    MOVWF MEM_SEG_VALUE_START + 4
    
    MOVLW 0x00
    MOVWF MEM_SEG_VALUE_START + 5    
    
    ;DO NOT CHANGE
    MOVLW 0x05 ;DO NOT CHANGE
    MOVWF MEM_SEG_VALUE_OFFSET ;DO NOT CHANGE
   ;DO NOT CHANGE
   
    RETURN
    
ALGO:
    ;GET THE VALUE OF N
    MOVF MEM_SEG_VALUE_OFFSET, W
    ;SELECT THE VALUE OF THE OFFSET
    ADDLW MEM_SEG_VALUE_START
    ;MOV TO FSR SO WE CAN GET VALUE
    MOVWF FSR
    ;MOV VALUE WHAT FSR POINTS TO WORKING REG
    MOVF INDF, W
    ;CLEAR THE STATUS 2ND (ZERO) BIT READY FOR THE COMPARISON
    BCF STATUS, 2
    ;SUB 9 FROM WORKING REG
    SUBLW 9
    ;IF THE VALUE WAS 9 THE 2ND BIT IN STATUS REG WILL BE 1
    BTFSC STATUS, 2
    GOTO ALGO_ITER ; THE BIT WAS SET SO ITERATE
    
    ;IF THE BIT WASNT SET INCREMENT N
    ;GET THE VALUE OF N
    MOVF MEM_SEG_VALUE_OFFSET, W
    ;SELECT THE VALUE OF THE OFFSET
    ADDLW MEM_SEG_VALUE_START
    ;MOV TO FSR SO WE CAN GET VALUE
    MOVWF FSR
    ;MOV VALUE WHAT FSR POINTS TO WORKING REG
    MOVF INDF, W
    ;ADD ONE TO IT
    ADDLW 0x01
    ;STORE IT BACK
    MOVWF INDF
    ;MOV 5 BACK TO OFFSET
    MOVLW 0x05
    MOVWF MEM_SEG_VALUE_OFFSET
    
    RETURN
    
ALGO_ITER:
    ;GET THE VALUE OF N
    MOVF MEM_SEG_VALUE_OFFSET, W
    ;SELECT THE VALUE OF THE OFFSET
    ADDLW MEM_SEG_VALUE_START
    ;MOV TO FSR SO WE CAN GET VALUE
    MOVWF FSR
    MOVLW 0x00; SET THE WORKIGN REG TO ZER
    MOVWF INDF ; SET WHAT FSR POINTS TO TO ZERO
    MOVLW 0x01
    SUBWF MEM_SEG_VALUE_OFFSET, 1 ;STORE RESULT OF SUB BACK IN MEM_SEG_VALUE_OFFSET
    GOTO ALGO
    
LOOP:    
    CALL DRAW
    CALL ALGO    
    
    GOTO LOOP
    END